namespace NumbatLogic
{
	class Scope : AST
	{
		public construct()
		{
			m_eType = AST::Type::AST_SCOPE;
		}

		public static Scope** TryCreate(TokenContainer pTokenContainer, OffsetDatum pOffsetDatum)
		{
			OffsetDatum* pTempOffset = own OffsetDatum::Create(pOffsetDatum);

			Token pOpeningToken = pTokenContainer.PeekExpect(pTempOffset, Token::Type::TOKEN_CURLY_BRACE_LEFT);
			if (pOpeningToken == null)
				return null;

			pTempOffset.m_nOffset = pTempOffset.m_nOffset+1;

			Scope* pScope = own new Scope();
			pScope.m_pFirstToken = pOpeningToken;

			while (true)
			{
				Token pClosingToken = pTokenContainer.PeekExpect(pTempOffset, Token::Type::TOKEN_CURLY_BRACE_RIGHT);
				if (pClosingToken != null)
				{
					pTempOffset.m_nOffset = pTempOffset.m_nOffset+1;
					break;
				}

				AST* pChild = own AST::CreateStatementFromTokenContainer(pTokenContainer, pTempOffset);
				if (pChild == null)
				{
					Console::Log("expected to parse somethting within scope...");
					Console::Log(pTokenContainer.StringifyOffset(pTempOffset));
					NumbatLogic::Assert::Plz(false);
					return null;
				}

				pScope.AddChild(disown pChild);
			}

			pOffsetDatum.Set(pTempOffset);
			return disown pScope;
		}

		public override void Validate(Validator pValidator, OperatorExpr pParent)
		{
			pValidator.BeginScope(this);

			// inject member vars for destructor
			if (m_pParent.m_eType == AST::Type::AST_TOR_DECL)
			{
				TorDecl pTorDecl = cast TorDecl(m_pParent);
				if (pTorDecl.m_pTypeToken.m_eType == Token::Type::TOKEN_KEYWORD_DESTRUCT)
				{
					if (pTorDecl.m_pParent.m_eType != AST::Type::AST_CLASS_DECL)
					{
						pValidator.AddError("Expected parent TorDecl to be child of AST_CLASS_DECL", m_pFirstToken.m_sFileName, m_pFirstToken.m_nLine, m_pFirstToken.m_nColumn);
						return;
					}

					AST pChild = pTorDecl.m_pParent.m_pFirstChild;
					while (pChild != null)
					{
						if (pChild.m_eType == AST::Type::AST_MEMBER_VAR_DECL)
						{
							MemberVarDecl pMemberVarDecl = cast MemberVarDecl(pChild);
							pValidator.AddVarDecl(pMemberVarDecl.m_pVarDecl);

							if (pMemberVarDecl.m_pVarDecl.m_pTypeRef.m_pTypeToken.m_eType == Token::Type::TOKEN_IDENTIFIER)
							{
								// also add to #includes
								string sTypeName = pMemberVarDecl.m_pVarDecl.m_pTypeRef.m_pTypeToken.GetString();
								AST pType = FindByName(sTypeName, this);
								
								if (pType != null && pType.m_eType == AST::Type::AST_CLASS_DECL)
								{
									ClassDecl pClassDecl = cast ClassDecl(pType);
									AddClassDeclReference(pClassDecl, AST::OutputFile::SOURCE, false);
								}
							}
						}

						pChild = pChild.m_pNextSibling;
					}
				}
			}

			base.Validate(pValidator, pParent);

			pValidator.EndScope(this);
		}

		public override void Stringify(Language eLanguage, OutputFile eOutputFile, int nDepth, InternalString sOut)
		{
			Util::Pad(nDepth, sOut);
			sOut.Append("{\n");

			AST pChild = m_pFirstChild;
			while (pChild != null)
			{
				pChild.Stringify(eLanguage, eOutputFile, nDepth+1, sOut);
				pChild = pChild.m_pNextSibling;
			}

			Util::Pad(nDepth, sOut);
			sOut.Append("}\n");
		}
	}
}